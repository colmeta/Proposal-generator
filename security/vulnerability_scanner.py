"""
Vulnerability Scanner
Dependency vulnerability scanning, code security checks
"""

import subprocess
import json
from typing import Dict, Any, List, Optional
from pathlib import Path
import logging

logger = logging.getLogger(__name__)


class VulnerabilityScanner:
    """
    Vulnerability scanner for dependencies and code security
    """
    
    def __init__(self):
        """Initialize vulnerability scanner"""
        logger.info("VulnerabilityScanner initialized")
    
    def scan_dependencies(self, requirements_file: Optional[Path] = None) -> Dict[str, Any]:
        """
        Scan dependencies for vulnerabilities using safety
        
        Args:
            requirements_file: Path to requirements.txt
        
        Returns:
            Scan results with vulnerabilities
        """
        if requirements_file is None:
            from config.settings import BASE_DIR
            requirements_file = BASE_DIR / "requirements.txt"
        
        if not requirements_file.exists():
            return {"error": "Requirements file not found", "vulnerabilities": []}
        
        try:
            # Try to use safety if available
            result = subprocess.run(
                ["safety", "check", "--json", "--file", str(requirements_file)],
                capture_output=True,
                text=True,
                timeout=60
            )
            
            if result.returncode == 0:
                # No vulnerabilities found
                return {
                    "status": "success",
                    "vulnerabilities": [],
                    "scanned_file": str(requirements_file)
                }
            else:
                # Parse vulnerabilities
                try:
                    vulnerabilities = json.loads(result.stdout)
                    return {
                        "status": "vulnerabilities_found",
                        "vulnerabilities": vulnerabilities,
                        "scanned_file": str(requirements_file)
                    }
                except json.JSONDecodeError:
                    return {
                        "status": "error",
                        "error": "Failed to parse safety output",
                        "output": result.stdout
                    }
        except FileNotFoundError:
            logger.warning("Safety not installed. Install with: pip install safety")
            return {
                "status": "tool_not_available",
                "message": "Safety tool not installed",
                "vulnerabilities": []
            }
        except subprocess.TimeoutExpired:
            return {
                "status": "timeout",
                "error": "Scan timed out"
            }
        except Exception as e:
            logger.error(f"Dependency scan failed: {e}")
            return {
                "status": "error",
                "error": str(e)
            }
    
    def check_security_best_practices(self) -> Dict[str, Any]:
        """
        Check code for security best practices
        
        Returns:
            Security check results
        """
        issues = []
        recommendations = []
        
        # Check for hardcoded secrets
        from config.settings import BASE_DIR
        secret_patterns = [
            ("password", r'password\s*=\s*["\']([^"\']+)["\']'),
            ("api_key", r'api[_-]?key\s*=\s*["\']([^"\']+)["\']'),
            ("secret", r'secret\s*=\s*["\']([^"\']+)["\']'),
        ]
        
        for pattern_name, pattern in secret_patterns:
            # This is a simplified check - in production, use bandit or similar
            pass
        
        # Check environment variable usage
        recommendations.append("Use environment variables for sensitive configuration")
        recommendations.append("Enable HTTPS/TLS for all connections")
        recommendations.append("Implement rate limiting")
        recommendations.append("Use parameterized queries to prevent SQL injection")
        recommendations.append("Validate and sanitize all user inputs")
        
        return {
            "status": "completed",
            "issues": issues,
            "recommendations": recommendations
        }
    
    def scan_code_security(self, code_path: Optional[Path] = None) -> Dict[str, Any]:
        """
        Scan code for security issues (using bandit if available)
        
        Args:
            code_path: Path to code directory
        
        Returns:
            Security scan results
        """
        if code_path is None:
            from config.settings import BASE_DIR
            code_path = BASE_DIR
        
        try:
            # Try to use bandit if available
            result = subprocess.run(
                ["bandit", "-r", str(code_path), "-f", "json"],
                capture_output=True,
                text=True,
                timeout=120
            )
            
            if result.returncode == 0:
                try:
                    scan_results = json.loads(result.stdout)
                    return {
                        "status": "success",
                        "results": scan_results,
                        "scanned_path": str(code_path)
                    }
                except json.JSONDecodeError:
                    return {
                        "status": "error",
                        "error": "Failed to parse bandit output"
                    }
        except FileNotFoundError:
            logger.warning("Bandit not installed. Install with: pip install bandit")
            return {
                "status": "tool_not_available",
                "message": "Bandit tool not installed"
            }
        except subprocess.TimeoutExpired:
            return {
                "status": "timeout",
                "error": "Scan timed out"
            }
        except Exception as e:
            logger.error(f"Code security scan failed: {e}")
            return {
                "status": "error",
                "error": str(e)
            }
    
    def validate_configuration_security(self) -> Dict[str, Any]:
        """
        Validate configuration security
        
        Returns:
            Configuration security validation results
        """
        issues = []
        from config import settings
        
        # Check for default/weak secrets
        if settings.DATABASE_URL and "sqlite" in settings.DATABASE_URL.lower():
            issues.append({
                "severity": "medium",
                "issue": "Using SQLite database (consider PostgreSQL for production)",
                "recommendation": "Use PostgreSQL with proper authentication"
            })
        
        # Check encryption key
        import os
        if os.getenv("ENCRYPTION_KEY") is None:
            issues.append({
                "severity": "high",
                "issue": "ENCRYPTION_KEY not set",
                "recommendation": "Set ENCRYPTION_KEY environment variable"
            })
        
        return {
            "status": "completed",
            "issues": issues,
            "secure": len(issues) == 0
        }


# Global instance
vulnerability_scanner = VulnerabilityScanner()

